// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

// USDC: 0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8

contract callOptionAut is AutomationCompatibleInterface {
    /**
     * Public counter variable
     */
    uint public counter;

    address public tokenAdddress = 0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8;
    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    AggregatorV3Interface internal dataFeed;
    using SafeMath for uint;


    struct option {
        uint strike;                                  //Price in USD (18 decimal places) option allows buyer to purchase tokens at
        uint premium;                                 //Fee in contract token that option writer charges
        uint expiry;                                  //Unix timestamp of expiration time
        uint amount;                                  //Amount of tokens the option contract is for
        bool exercised;                               //Has option been exercised
        //bool canceled;                                //Has option been canceled
        //uint id;                                      //Unique ID of option, also array index
        //uint latestCost;                              //Helper to show last updated cost to exercise
        address payable writer;                       //Issuer of option
        address payable buyer;                        //Buyer of option
    }

    option public opt;

    constructor () {
    dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);                // ETH/USD   
    }

    function getLatestData() public view returns (int, uint) {
        (
            /* uint80 roundID */,
            int answer,
            uint startedAt,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = dataFeed.latestRoundData();
        return (answer, startedAt);
    }


    function writeOption(uint strike, uint T, uint tknum, uint _premium) public payable{
        require(msg.value == tknum, "Incorrect amount of ETH supplied");                       //Transfer ETH to this contract     tknum 那里的单位是wei 就是Value那里的单位 
        uint premium = _premium;                                     // 1 eth = 10**18 wei        premium
        //(, uint startTime) = getLatestData();
        opt =  option(strike, premium, T+block.timestamp, tknum, false, payable(msg.sender), payable(address(0)));
    }

    function withdraw() public payable{
        require(opt.expiry < block.timestamp + 600, "Option is not expired");
        require(opt.exercised == false);

        opt.writer.transfer(opt.amount); 
    }
    
    function buyOption() public payable {
        require(msg.value == opt.premium, "Incorrect amount of ETH sent for premium");   //Transfer premium payment from buyer
        opt.writer.transfer(opt.premium);
        opt.buyer = payable(msg.sender);
    }

    function calculateUsdc() public view returns (uint) {
        return (opt.amount * opt.strike)/(10**20);
    }

    function getTime() view public returns (uint) {
        return block.timestamp;
    }

    function excute() public payable {
        require(msg.sender == 0xE16Df59B887e3Caa439E0b29B42bA2e7976FD8b2);
        uint udsc = calculateUsdc();

        IERC20(tokenAdddress).transferFrom(opt.buyer, opt.writer, udsc);
        payable(opt.buyer).transfer(opt.amount); 
        opt.exercised = true;
    }

    function checkUpkeep(                              // return true -> performUpkeep                           
        bytes calldata /* checkData */
    )
        external
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {   
        upkeepNeeded = (block.timestamp - opt.expiry) > 0 && opt.exercised == false;
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        excute();
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}
